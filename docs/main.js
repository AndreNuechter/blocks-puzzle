window.addEventListener('DOMContentLoaded', ()=>{ if ('serviceWorker' in window.navigator) { window.navigator.serviceWorker.register('./service-worker.js'); } }, { once: true }); if ('wakeLock' in navigator && 'request' in navigator.wakeLock) { const getWakeLock = ()=>navigator.wakeLock.request('screen'); getWakeLock(); document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible') { getWakeLock(); } }); } const stepSize = 1; const lineClearMultipliers = [ 0, 100, 300, 500, 800 ]; const touchInputDelay = 100; const colors = [ 'lightgrey', '#ffd633', '#0066ff', '#e60000', '#33cc33', '#9933ff', '#996633', '#ff711e' ]; const eventNames = { gameStarted: 'game-started', gamePaused: 'game-paused', gameEnded: 'game-ended', scoreHandled: 'score-handled' }; function iterate(arr, cb) { arr.forEach((row, y)=>row.forEach((cell, x)=>{ if (cell > 0) { cb(y, x, cell); } })); } function lastItem(arr) { return arr[lastId(arr)]; } function lastId(arr) { return arr.length - 1; } function randomId(arrLength) { return Math.floor(Math.random() * arrLength); } function rotate2dArray(arr, length = arr.length) { const res = Array.from({ length }, ()=>new Array(length)); for(let y = 0; y < length; y += 1){ for(let x = 0; x < length; x += 1){ res[y][x] = arr[length - x - 1][y]; } } return res; } function getColor(colors, piece1) { return colors[piece1[1][1] || piece1[2][2]]; } function dispatchCustomEvent(eventName) { document.dispatchEvent(new Event(eventName)); } function collidesVertically(field, piece1, piecePosition, distance) { return piece1.some((row, y)=>{ const idOfNextRow = y + piecePosition.y + distance; if (row.every((cell)=>cell === 0)) return false; if (idOfNextRow >= 20) return true; return row.some((cell, x)=>cell !== 0 && field[idOfNextRow][x + piecePosition.x] !== 0); }); } function collidesHorizontally(field, piece1, piecePosition, distance) { return piece1.some((row, y)=>{ const idOfCurrentRow = y + piecePosition.y; return row.some((cell, x)=>{ const idOfNextCell = x + piecePosition.x + distance; if (idOfNextCell >= 10 && piece1.some((row)=>row[x] !== 0)) return true; return cell !== 0 && field[idOfCurrentRow][idOfNextCell] !== 0; }); }); } function isColliding(field, piece1, piecePosition) { return collidesHorizontally(field, piece1, piecePosition, 0) || collidesVertically(field, piece1, piecePosition, 0); } const pieces = Object.values({ line: [ [ 0, 0, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 1, 0 ] ], s: [ [ 0, 2, 2 ], [ 2, 2, 0 ], [ 0, 0, 0 ] ], z: [ [ 3, 3, 0 ], [ 0, 3, 3 ], [ 0, 0, 0 ] ], l: [ [ 0, 4, 0 ], [ 0, 4, 0 ], [ 0, 4, 4 ] ], r: [ [ 0, 5, 5 ], [ 0, 5, 0 ], [ 0, 5, 0 ] ], o: [ [ 6, 6 ], [ 6, 6 ] ], t: [ [ 0, 7, 0 ], [ 7, 7, 7 ], [ 0, 0, 0 ] ] }); const pieceQueue = new Array(5).fill([]); const field = Array.from({ length: 20 }, ()=>new Array(10)); function getRandomPiece() { return pieces[randomId(pieces.length)]; } const overlay = document.getElementById('overlay'); const fieldCanvas = document.getElementById('field-canvas').getContext('2d', { alpha: false }); const currentPieceCanvas = document.getElementById('current-piece-canvas').getContext('2d'); const pieceCacheCanvas = document.getElementById('piece-cache').getContext('2d', { alpha: false }); const piecePreview = document.getElementById('piece-preview').getContext('2d', { alpha: false }); const pointsDisplay = document.getElementById('points-display'); const clearedLinesCountDisplay = document.getElementById('cleared-lines-count-display'); const gameSummaryText = document.getElementById('game-summary__text'); const gameSummaryTable = document.getElementById('game-summary__table'); const playerNameInput = document.querySelector('input[name="player-name"]'); const highscores = JSON.parse(localStorage.getItem('blocks-puzzle-hi-scores')) || []; const maxHighscores = 10; const newScore = { name: '', points: 0, clearedLinesCount: 0, position: -1 }; document.addEventListener(eventNames.scoreHandled, ()=>{ overlay.classList.remove('asking-player-name'); gameSummaryTable.innerHTML = getHighscores(); playerNameInput.value = ''; }); document.getElementById('player-name-form').addEventListener('submit', (event)=>{ event.preventDefault(); newScore.name = playerNameInput.value; addHighscore(newScore); dispatchCustomEvent(eventNames.scoreHandled); }); function handleScore(points, clearedLinesCount) { const position = getPosition(points); Object.assign(newScore, { points, clearedLinesCount, position }); if (position > -1) { overlay.classList.add('asking-player-name'); playerNameInput.focus(); } else { dispatchCustomEvent(eventNames.scoreHandled); } } function getHighscores() { if (highscores.length === 0) return ''; return '<tr><th>#<th>Points<th>Cleared<th>Name</tr>' + highscores.map(({ points , clearedLinesCount , name }, position)=>{ const className = position === newScore.position ? ' class="newest-score"' : ''; return ` <tr ${classname}><td>${position + 1}<td>${points}<td>${clearedLinesCount}<td>${name}</tr>`; }).join(''); } function getPosition(newPoints) { if (newPoints === 0) return -1; const position = highscores.findIndex(({ points: oldPoints })=>newPoints > oldPoints); return position < 0 && highscores.length < 10 ? highscores.length : position; } function addHighscore({ points , clearedLinesCount , name , position }) { highscores.splice(position, 0, { points, clearedLinesCount, name }); highscores.length = Math.min(highscores.length, maxHighscores); localStorage.setItem('blocks-puzzle-hi-scores', JSON.stringify(highscores)); } function clearCanvas(ctx) { ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); } const cellSize = { value: undefined }; let points = 0; function colorCanvasGrey(ctx) { ctx.fillStyle = colors[0]; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height); } setSizes(); window.addEventListener('resize', ()=>{ setSizes(); redrawCanvases(); }); function setSizes() { const currentCellSize = Math.floor(Math.min(30, (window.innerHeight - 110) / 20, (window.innerWidth - 220) / 10)); cellSize.value = currentCellSize; Object.assign(fieldCanvas.canvas, { width: 10 * currentCellSize + 1, height: 20 * currentCellSize + 1 }); Object.assign(fieldCanvas.canvas.parentElement.style, { width: 10 * currentCellSize + 1 + 'px', height: 20 * currentCellSize + 1 + 'px' }); Object.assign(currentPieceCanvas.canvas, { width: 4 * currentCellSize + 1, height: 4 * currentCellSize + 1 }); Object.assign(piecePreview.canvas, { width: (4 - 1) * currentCellSize * 0.5 + 1, height: 4 * 5 * currentCellSize * 0.5 + 1 }); Object.assign(pieceCacheCanvas.canvas, { width: 4 * currentCellSize * 0.5 + 1, height: 4 * currentCellSize * 0.5 + 1 }); } function draw2dArray(ctx, array, { offsets ={ x: 0, y: 0 } , scalingFactor =1 , variableColors =false } = { offsets: { x: 0, y: 0 }, scalingFactor: 1, variableColors: false }) { const currentCellSize = Math.floor(cellSize.value * scalingFactor); if (!variableColors) ctx.fillStyle = getColor(colors, array); iterate(array, (i, j, cell)=>{ const x = (j + offsets.x) * currentCellSize + 0.5; const y = (i + offsets.y) * currentCellSize + 0.5; if (variableColors) ctx.fillStyle = colors[cell]; ctx.fillRect(x, y, currentCellSize, currentCellSize); ctx.strokeRect(x, y, currentCellSize, currentCellSize); }); } function translateCanvas(ctx, x, y) { ctx.canvas.style.transform = `translate(${x * cellSize.value}px, ${y * cellSize.value}px)`; } let clearedLinesCount = 0; let currentPiece; let cachedPiece; let x; let y; const __default = { get points () { return points; }, set points (value){ points = value; pointsDisplay.textContent = value; }, get clearedLinesCount () { return clearedLinesCount; }, set clearedLinesCount (value){ clearedLinesCount = value; clearedLinesCountDisplay.textContent = value; }, get currentPiece () { return currentPiece; }, set currentPiece (piece){ currentPiece = piece; clearCanvas(currentPieceCanvas); if (piece) { draw2dArray(currentPieceCanvas, piece); } }, get cachedPiece () { return cachedPiece; }, set cachedPiece (piece){ cachedPiece = piece; colorCanvasGrey(pieceCacheCanvas); draw2dArray(pieceCacheCanvas, piece, { scalingFactor: 0.5 }); }, piecePosition: { get x () { return x; }, set x (value){ x = value; translateCanvas(currentPieceCanvas, x, y); }, get y () { return y; }, set y (value){ y = value; translateCanvas(currentPieceCanvas, x, y); } }, isGamePaused: undefined, linesAreBeingCleared: false }; function redrawCanvases() { colorCanvasGrey(fieldCanvas); colorCanvasGrey(piecePreview); colorCanvasGrey(pieceCacheCanvas); clearCanvas(currentPieceCanvas); translateCanvas(currentPieceCanvas, __default.piecePosition.x, __default.piecePosition.y); draw2dArray(fieldCanvas, field, { variableColors: true }); draw2dArray(currentPieceCanvas, __default.currentPiece); if (pieceQueue[0].length) { pieceQueue.forEach((upcomingPiece, i)=>{ draw2dArray(piecePreview, upcomingPiece, { offsets: { x: 0, y: i * 4 }, scalingFactor: 0.5 }); }); } if (__default.cachedPiece) { draw2dArray(pieceCacheCanvas, __default.cachedPiece, { scalingFactor: 0.5 }); } } document.addEventListener(eventNames.gameStarted, ()=>{ overlay.classList.remove('fresh', 'paused', 'game-over'); overlay.classList.add('playing'); }); document.addEventListener(eventNames.gamePaused, ()=>{ overlay.classList.replace('playing', 'paused'); }); document.addEventListener(eventNames.gameEnded, ()=>{ overlay.classList.replace('playing', 'game-over'); gameSummaryText.textContent = `You got ${points} points for clearing ${clearedLinesCount} lines`; handleScore(points, clearedLinesCount); }); let animationRequestId; let lastTick; document.addEventListener(eventNames.gameStarted, startAnimation); document.addEventListener(eventNames.gamePaused, suspendAnimation); function gameLoop(timestamp) { if (lastTick === undefined) { lastTick = timestamp; } if (!__default.linesAreBeingCleared && timestamp - lastTick >= 1000 - 3.33 * __default.clearedLinesCount) { lastTick = timestamp; applyGravity(); } animationRequestId = requestAnimationFrame(gameLoop); } function startGame() { field.forEach((row)=>row.fill(0)); Object.assign(__default, { points: 0, clearedLinesCount: 0 }); pieceQueue.forEach((_, i)=>{ pieceQueue[i] = getRandomPiece(); }); colorCanvasGrey(pieceCacheCanvas); colorCanvasGrey(fieldCanvas); spawnNewPiece(); } function startAnimation() { __default.isGamePaused = false; animationRequestId = requestAnimationFrame(gameLoop); } function suspendAnimation() { __default.isGamePaused = true; cancelAnimationFrame(animationRequestId); } function endGame() { suspendAnimation(); __default.isGamePaused = undefined; lastTick = undefined; dispatchCustomEvent(eventNames.gameEnded); } function translateXPiece(delta) { if (!collidesHorizontally(field, __default.currentPiece, __default.piecePosition, delta)) { __default.piecePosition.x += delta; } } function rotatePiece() { const rotatedPiece = rotate2dArray(__default.currentPiece); if (!isColliding(field, rotatedPiece, __default.piecePosition)) { __default.currentPiece = rotatedPiece; } else { if (__default.piecePosition.x < 10 / 2) { if (!isColliding(field, rotatedPiece, { x: __default.piecePosition.x + 1, y: __default.piecePosition.y })) { __default.currentPiece = rotatedPiece; __default.piecePosition.x += 1; } else if (!isColliding(field, rotatedPiece, { x: __default.piecePosition.x + 2, y: __default.piecePosition.y })) { __default.currentPiece = rotatedPiece; __default.piecePosition.x += 2; } } else { if (!isColliding(field, rotatedPiece, { x: __default.piecePosition.x - 1, y: __default.piecePosition.y })) { __default.currentPiece = rotatedPiece; __default.piecePosition.x -= 1; } else if (!isColliding(field, rotatedPiece, { x: __default.piecePosition.x - 2, y: __default.piecePosition.y })) { __default.currentPiece = rotatedPiece; __default.piecePosition.x -= 2; } } } } function applyGravity() { if (!collidesVertically(field, __default.currentPiece, __default.piecePosition, 1)) { __default.piecePosition.y += stepSize; } else { lockPiece(); clearLinesAndSpawnNewPiece(); } } function lockPiece() { iterate(__default.currentPiece, (y, x, cell)=>{ field[__default.piecePosition.y + y][__default.piecePosition.x + x] = cell; }); draw2dArray(fieldCanvas, __default.currentPiece, { offsets: __default.piecePosition }); __default.currentPiece = undefined; } function clearLinesAndSpawnNewPiece() { const indicesOfClearedRows = field.reduce((result, row, y)=>{ if (row.some((cell)=>cell === 0)) return result; row.fill(0); result.push(y); return result; }, []); if (indicesOfClearedRows.length > 0) { Object.assign(__default, { points: __default.points + lineClearMultipliers[indicesOfClearedRows.length] * (Math.floor(__default.clearedLinesCount * 0.1) + 1), clearedLinesCount: __default.clearedLinesCount + indicesOfClearedRows.length, linesAreBeingCleared: true }); colorCanvasGrey(fieldCanvas); draw2dArray(fieldCanvas, field, { variableColors: true }); setTimeout(()=>{ __default.linesAreBeingCleared = false; colorCanvasGrey(fieldCanvas); draw2dArray(fieldCanvas, field, { variableColors: true }); spawnNewPiece(); }, 400); indicesOfClearedRows.forEach((y)=>field.unshift(...field.splice(y, 1))); } else { spawnNewPiece(); } } function spawnNewPiece() { Object.assign(__default.piecePosition, { x: 4, y: 0 }); __default.currentPiece = progressPieceQueue(); if (isColliding(field, __default.currentPiece, __default.piecePosition)) { endGame(); } } function stashPiece() { if (!isColliding(field, __default.cachedPiece || lastItem(pieceQueue), __default.piecePosition)) { if (__default.cachedPiece) { [__default.currentPiece, __default.cachedPiece] = [ __default.cachedPiece, __default.currentPiece ]; } else { __default.cachedPiece = __default.currentPiece; __default.currentPiece = progressPieceQueue(); } } } function progressPieceQueue() { const emittedPiece = pieceQueue.pop(); colorCanvasGrey(piecePreview); pieceQueue.unshift(getRandomPiece()); pieceQueue.forEach((upcomingPiece, i)=>{ draw2dArray(piecePreview, upcomingPiece, { offsets: { x: 0, y: i * 4 }, scalingFactor: 0.5 }); }); return emittedPiece; } const isTouchDevice = window.matchMedia('(hover: none)').matches; const [handler, downEvent, upEvent] = isTouchDevice ? [ handlePointerdown, 'pointerdown', 'pointerup' ] : [ handleKeydown, 'keydown', 'keyup' ]; const once = { once: true }; let touchInputIntervalId; window.addEventListener(upEvent, triggerGameLoop, once); document.addEventListener(eventNames.gameStarted, ()=>window.addEventListener(downEvent, handler)); document.addEventListener(eventNames.gamePaused, ()=>{ window.removeEventListener(downEvent, handler); window.addEventListener(upEvent, ()=>{ window.addEventListener(downEvent, ()=>dispatchCustomEvent(eventNames.gameStarted), once); }, once); }); document.addEventListener(eventNames.gameEnded, ()=>window.removeEventListener(downEvent, handler)); if (isTouchDevice) { const pressedCssClass = 'pressed-down'; const pressTarget = ({ target })=>target.classList.add(pressedCssClass); const releaseTarget = ({ target })=>target.classList.remove(pressedCssClass); document.querySelectorAll('.control-element').forEach((element)=>{ element.addEventListener(downEvent, pressTarget); element.addEventListener(upEvent, releaseTarget); element.addEventListener('pointerleave', releaseTarget); }); document.addEventListener(eventNames.scoreHandled, ()=>{ window.addEventListener(downEvent, triggerGameLoop, once); }); const listener = ()=>clearInterval(touchInputIntervalId); window.addEventListener(upEvent, listener); document.addEventListener(eventNames.gameEnded, listener); } else { document.addEventListener(eventNames.scoreHandled, ()=>{ window.addEventListener(upEvent, ()=>{ window.addEventListener(downEvent, triggerGameLoop, once); }, once); }); } function triggerGameLoop() { startGame(); dispatchCustomEvent(eventNames.gameStarted); } function handleKeydown({ key , ctrlKey }) { if (__default.linesAreBeingCleared) return; if (__default.isGamePaused) { dispatchCustomEvent(eventNames.gameStarted); } else if (key === 'ArrowDown' || key.toLowerCase() === 's') { applyGravity(); } else if (key === 'ArrowLeft' || key.toLowerCase() === 'a') { translateXPiece(-1); } else if (key === 'ArrowRight' || key.toLowerCase() === 'd') { translateXPiece(1); } else if (key === 'ArrowUp' || key.toLowerCase() === 'w') { rotatePiece(); } else if (key === ' ') { dispatchCustomEvent(eventNames.gamePaused); } else if (ctrlKey) { stashPiece(); } } const repeatedTouchActions = { ArrowDown: ()=>{ if (__default.linesAreBeingCleared) return; applyGravity(); vibrate(); }, ArrowLeft: ()=>{ if (__default.linesAreBeingCleared) return; translateXPiece(-1); vibrate(); }, ArrowRight: ()=>{ if (__default.linesAreBeingCleared) return; translateXPiece(1); vibrate(); } }; function handlePointerdown({ target: { dataset: { name } } }) { if (__default.linesAreBeingCleared) return; if (__default.isGamePaused) { dispatchCustomEvent(eventNames.gameStarted); } else { switch(name){ case 'ArrowDown': case 'ArrowLeft': case 'ArrowRight': repeatTillPointerup(repeatedTouchActions[name]); break; case 'ArrowUp': rotatePiece(); vibrate(); break; case 'a': dispatchCustomEvent(eventNames.gamePaused); break; case 'b': stashPiece(); vibrate(); break; } } } function repeatTillPointerup(action) { action(); touchInputIntervalId = setInterval(action, touchInputDelay); } function vibrate() { window.navigator.vibrate(100 / 3); }